package org.openstreetmap.josm.gradle.plugin.io

import org.gradle.api.Project
import org.openstreetmap.josm.gradle.plugin.task.GeneratePluginList
import org.openstreetmap.josm.gradle.plugin.util.josm
import org.openstreetmap.josm.gradle.plugin.util.josmPluginList
import java.net.MalformedURLException
import java.net.URL

/**
 * Reads a plugin info file like it is found at [https://josm.openstreetmap.de/plugin]
 * or [https://josm.openstreetmap.de/pluginicons] or like it's generated by [GeneratePluginList].
 *
 * The file is immediately read on construction, the found plugins can then be retrieved by accessing [plugins],
 * any errors that occured while parsing can be retrieved by accessing [errors]. If there are no parsing errors,
 * [errors] will be an empty list.
 */
class JosmPluginListParser(val project: Project, val withIcons: Boolean = false) {

  companion object {
    val TITLE_LINE_REGEX = Regex("^([^;]+)(\\.jar)?;(.+)$")
    val MANIFEST_LINE_REGEX = Regex("^\t([^:]+): (.*)$")
  }

  val errors: List<String>

  val plugins: List<PluginInfo>

  init {
    val errors: MutableList<String> = mutableListOf()
    val plugins: MutableList<PluginInfo> = mutableListOf()

    // Resolve plugin list as dependency
    val dependency = project.dependencies.josmPluginList(withIcons)
    val conf = project.configurations.detachedConfiguration(dependency)
    val repo = project.repositories.josmPluginList(conf, dependency)
    val resolvedFiles = conf.resolve()
    project.repositories.remove(repo)

    require(resolvedFiles.size == 1) { "The plugin list was not resolved correctly!" }

    // Temporary variables to collect properties of the next PluginInfo object
    var pluginName: String? = null
    var downloadUrl: URL? = null
    val manifestAtts: MutableMap<String, String> = mutableMapOf()

    resolvedFiles.first().readLines().forEachIndexed { i, line ->
      val manifestLineMatch = MANIFEST_LINE_REGEX.matchEntire(line)
      // A line from a Java Manifest (indented by a tab)
      if (manifestLineMatch != null) {
        if (pluginName == null || downloadUrl == null) {
          errors.add("Line $i: Found a line from a manifest, but can't determine the plugin name and URL where it belongs to.")
        } else {
          manifestAtts[manifestLineMatch.groupValues[1]] = manifestLineMatch.groupValues[2]
        }
      } else {
        val titleLineMatch = TITLE_LINE_REGEX.matchEntire(line)
        // A plugin title line
        if (titleLineMatch != null) {
          PluginInfo.build(pluginName, downloadUrl, manifestAtts)?.let { plugins.add(it) }
          if ((pluginName == null || downloadUrl == null) && (pluginName != null || downloadUrl != null || manifestAtts.isNotEmpty())) {
            errors.add("Line $i: The plugin before this line was incomplete (name: $pluginName, URL $downloadUrl, ${manifestAtts.size} manifest attributes)")
          }
          manifestAtts.clear()
          pluginName = titleLineMatch.groupValues[1]
          try {
            downloadUrl = URL(titleLineMatch.groupValues[3])
          } catch (e: MalformedURLException) {
            errors.add("Line $i: Plugin $pluginName has a malformed download URL set!")
            pluginName = null
            downloadUrl = null
          }
        } else { // unrecognized line, reset current plugin
          PluginInfo.build(pluginName, downloadUrl, manifestAtts)?.let { plugins.add(it) } // add current plugin, if one already begun
          errors.add("Line $i: This line has an unrecognized format. If this is in the middle of a plugin info block, the rest of the block will be cut off.")
          pluginName = null
          downloadUrl = null
          manifestAtts.clear()
        }
      }
    }
    PluginInfo.build(pluginName, downloadUrl, manifestAtts)?.let { plugins.add(it) }

    this.plugins = plugins
    this.errors = errors
  }
}
